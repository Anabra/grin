\documentclass[main.tex]{subfiles}
\begin{document}
	
	GRIN is short for \emph{Graph Reduction Intermediate Notation}. GRIN consists of an intermediate representation language (IR in the followings) as well as the entire compiler back end framework built around it. GRIN tries to resolve the issues presented in Section~\ref{sec-intro} by making interprocedural whole program analysis and optimization possible on a general intermediate language. 
	
	First of all, interprocedural data-flow analysis preserves and propagates the flow of information through function calls allowing for optimizations across these functions. This means the framework can handle a large set of small interconnecting functions. Secondly, whole program analysis enables the optimization of global functions across modules. As a consequence, the implicit evaluation of suspended computations can be made explicit. In fact, the value forcing in GRIN is done by an ordinary function called \pilcode{eval}. This is a global function uniquely generated for each program, implying it can be optimized just like any other function with the help of whole program analysis. Finally, GRIN can act as a common IR for all functional languages. After compiling programs written in those languages to the GRIN IR, they can be optimized and then low level machine code can be generated from them.
	
	The intermediate layer of GRIN between the front end language and the low level machine code serves the purpose of eliminating functional artifacts from programs. This is achieved by using optimizing program transformations specific to the GRIN IR and functional languages in general. The simplified programs can then be optimized further using conventional techniques already available. For example, it is possible to compile GRIN to LLVM and take advantage of an entire compiler framework providing a huge array of very powerful tools and features.
	
	% TODO: refer LLVM section
	
\end{document}