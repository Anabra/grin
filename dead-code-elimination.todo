Dead data elimination:
  - for DDE, we assume that node name introduction has already taken place
  - for dummy substitution LVA is sufficient
  - for field deletion, CBy analysis is also required
    - we have to scrutinize every case expression, and group the overlapping producers together
    - in order to be able to delete a field (wtih a given tag), that field must be dead (with the given tag) for all producers in the group
  - when deleting node fields, some expressions might still reference them
  - so we must bind #undefineds to these names to produce semantically valid code 
    (these will be cleaned up by DVE)

Dead parameter elimination:
  - delete dead parameters from function definitions
  - delete the same arguments from function applications as well
  - we have to bind #undefineds to the deleted function parameters inside the function body 
    (see DDE reasoning)

Dead function elimination:
  - a function definition can be removed if its return value and all of its arguments are dead 
  - a parameter can be live even though the return value is dead, if it has some sort of side effect
    e.g.: it's a pointer that is updated, or a side-effecting primop is called on it
  - replace funapp bindings with #undefined (where the function was deleted)
  - when deleting a store, update #undefined types

Dead variable elimination:
  - for (y <- pure x) bindings, delete the binding if y is dead
  - for (y <- fun args) bindings, we can only delete it, if fun's return value and all of its arguments are dead
  - for (x <- fetch p) bindings, delete it if x is dead 
  - for (p <- store x) bindings, delete it if p is dead 
  - for (update p x), delete it if p is dead 
  - when deleting a binding, replace all occurences of the deleted name with #undefined
  - when deleting a store, update #undefined types

TODO:
  HIGH:
    - make sure, that all dead code elimination transfromations handle effectful functions correctly
    - apply inlining should also inline ap
    - implement type safe undefined node generation for tests (Test.Test) 
  
  LOW:
    - implement type env transformation for DDE
    - linter should check whether calculated types match with annotations
    - tests: HeapIndirectSimple -> HeapIndirectComplex ? 
  
  NOTES:
    - before optimising P nodes, make sure to test whether the current optimisations are unable to handle the task

  QUESTIONS:
    - do all P nodes of the same function have the same liveness?
    (even after apply inlining)
    - if they do, can their fields be deleted solely based on the function args' liveness?
  
  if they do:
    - we don't have to introduce new names for them (probably same for F nodes)
    - (args' == args after dde) and (l == no. live args of foo) and (n == no. args'): 
    - PNfoo args --> P(l-n)foo args'
    - if last argument is deleted, then do ... ?

  Indexed store:
    ✔ introduce indexed store AST node @done(18-11-01 21:48)
    ✔ modify dataflow analyses to correctly handle indexed store @done(18-11-02 20:58)
    - extend linter so that it checks whether indexed stores are used correctly
      - the AST should either contain only non-indexed stores
      - or continously increasing indexed stores starting from 0
    - make sure that CSE           correctly handles indexed stores
    - make sure that ArityRaising  correctly handles indexed stores
    - make sure that PNI           correctly handles indexed stores
    - make sure that RegIntro      correctly handles indexed stores
    - make sure that Vectorisation correctly handles indexed stores

    - #undefined nodes should always rely only on indexed stores, never on unindexed ones
    - we should always index stores before any transformation that can introduce #undefineds
    - this way deleting a store will never invalidate the #undefineds' types
    - there is one edge case: 
      - when deleting the store with the highest index
      - then calculating the type env again (using HPT)
      - some #undefineds' types will refer to non-existent heap locations 
      - we should delete the deleted locations from #undefineds' types

  Store reindexing:
    - store reindexing transformation should not be called on AST's with #undefineds (since it can invalidate their types)
    - call it before dead code elimination, once
    - make sure, that inlining transformations introduce indexed stores

  Store indexing:
    - indexes only unindexed stores
    - can be called anytime, will not invalidate types that rely on only indexed stores
  
Archive:
  ✔ genProgWith (in Test.Test) -> readd dead parameter elimination @done(18-10-30 22:23) @project(TODO.LOW)
  ✔ rename dead procedure elimination to dead function elimination @done(18-10-30 22:23) @project(TODO.LOW)
  ✔ make sure, that dead procedure elimination does not produce semantically invalid code @done(18-10-29 10:31) @project(TODO.HIGH)
  ✘ store variable name <-> heap location is a bijective mapping @cancelled(18-10-28 23:34)
  ✘ make sure that dead (data/parameter/procedure/variable) elimination are executed after each other in the pipeline @cancelled(18-10-28 23:33)
  ✔ fix confuence test behaviour for analysis based transformations @done(18-10-28 23:32)
  ✔ lift Undefined to Val level @done(18-10-12 22:43) @project(TODO)
  ✔ introduce type annotations @done(18-10-12 22:43) @project(TODO)
  ✔ pretty print type annotations @done(18-10-12 22:45) @project(TODO)
  ✔ introduce heap type annotations in the begininning of the program @done(18-10-12 22:43) @project(TODO)
  ✔ write parser for type annotations @done(18-10-12 22:43) @project(TODO)
  ✔ Grin.Grin FoldNames @done(18-10-14 00:56) @project(TODO)
  ✔ rename node name introduction to producer name introduction @done(18-10-14 01:17) @project(TODO)
  ✔ this transformation only has to introduce new name for producers, @done(18-10-14 01:17) @project(TODO)
  ✘ write tests for node name introduction @cancelled(18-10-12 22:44) @project(TODO)
  ✘ introduce new names for applications: @cancelled(18-10-12 22:44) @project(TODO)
  ✔ implement heap type env parsing @done(18-10-12 22:44) @project(TODO)
  ✔ implement annotated line type env parsing @done(18-10-12 22:44) @project(TODO)
  ✔ extend HPT (and CBy) so that they gather type info from #undefined nodes @started(18-10-12 22:44) @done(18-10-14 00:52) @lasted(1d2h8m35s) @project(TODO)
  ✔ tests for HPT, CBy with undefineds @done(18-10-14 00:52) @project(TODO)
